/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.15.3.0 (NJsonSchema v9.10.27.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams, HttpResponse, HttpResponseBase, HttpErrorResponse } from '@angular/common/http';

import * as moment from 'moment';
import {BaseClient} from './services/base-client.service';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class UserClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    addImage(image: FileParameter): Observable<any> {
        let url_ = this.baseUrl + "/users/addImage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (image === null || image === undefined)
            throw new Error("The parameter 'image' cannot be null.");
        else
            content_.append("image", image.data, image.fileName ? image.fileName : "image");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processAddImage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddImage(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processAddImage(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }

    /**
     * @return Ok
     */
    registerUser(newUserParams: NewUserParams): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUserParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterUser(<any>response_);
                } catch (e) {
                    return <Observable<UserVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterUser(response: HttpResponseBase): Observable<UserVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getUserByUsername(username: string): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetUserByUsername(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserByUsername(<any>response_);
                } catch (e) {
                    return <Observable<UserVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm>><any>Observable.throw(response_);
        });
    }

    protected processGetUserByUsername(response: HttpResponseBase): Observable<UserVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm>(<any>null);
    }

    /**
     * @return Ok
     */
    login(loginParams: LoginParams): Observable<LoginVm> {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<LoginVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<LoginVm>><any>Observable.throw(response_);
        });
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginVm.fromJS(resultData200) : new LoginVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<LoginVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAllUsers(): Observable<UserVm[]> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAllUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllUsers(<any>response_);
                } catch (e) {
                    return <Observable<UserVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllUsers(response: HttpResponseBase): Observable<UserVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteUserById(id: string): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteUserById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUserById(<any>response_);
                } catch (e) {
                    return <Observable<UserVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm>><any>Observable.throw(response_);
        });
    }

    protected processDeleteUserById(response: HttpResponseBase): Observable<UserVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm>(<any>null);
    }

    /**
     * @return Ok
     */
    udpateUserById(id: string, updateUserParams: NewUserParams): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateUserParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUdpateUserById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUdpateUserById(<any>response_);
                } catch (e) {
                    return <Observable<UserVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm>><any>Observable.throw(response_);
        });
    }

    protected processUdpateUserById(response: HttpResponseBase): Observable<UserVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm>(<any>null);
    }
}

@Injectable()
export class EntryClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerEntry(newEntryParams: NewEntryParams): Observable<EntryVm> {
        let url_ = this.baseUrl + "/entries/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newEntryParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterEntry(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterEntry(<any>response_);
                } catch (e) {
                    return <Observable<EntryVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<EntryVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterEntry(response: HttpResponseBase): Observable<EntryVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EntryVm.fromJS(resultData200) : new EntryVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EntryVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<EntryVm[]> {
        let url_ = this.baseUrl + "/entries/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<EntryVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<EntryVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponseBase): Observable<EntryVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntryVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EntryVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    getSingleEntry(id: string): Observable<EntryVm> {
        let url_ = this.baseUrl + "/entries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetSingleEntry(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleEntry(<any>response_);
                } catch (e) {
                    return <Observable<EntryVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<EntryVm>><any>Observable.throw(response_);
        });
    }

    protected processGetSingleEntry(response: HttpResponseBase): Observable<EntryVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EntryVm.fromJS(resultData200) : new EntryVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EntryVm>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteEntry(id: string): Observable<EntryVm> {
        let url_ = this.baseUrl + "/entries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteEntry(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteEntry(<any>response_);
                } catch (e) {
                    return <Observable<EntryVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<EntryVm>><any>Observable.throw(response_);
        });
    }

    protected processDeleteEntry(response: HttpResponseBase): Observable<EntryVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EntryVm.fromJS(resultData200) : new EntryVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EntryVm>(<any>null);
    }

    /**
     * @return Ok
     */
    updateEntry(harvestId: string, updatedEntryVm: EntryVm): Observable<HarvestVm> {
        let url_ = this.baseUrl + "/entries/{harvestId}";
        if (harvestId === undefined || harvestId === null)
            throw new Error("The parameter 'harvestId' must be defined.");
        url_ = url_.replace("{harvestId}", encodeURIComponent("" + harvestId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedEntryVm);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateEntry(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateEntry(<any>response_);
                } catch (e) {
                    return <Observable<HarvestVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvestVm>><any>Observable.throw(response_);
        });
    }

    protected processUpdateEntry(response: HttpResponseBase): Observable<HarvestVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HarvestVm.fromJS(resultData200) : new HarvestVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvestVm>(<any>null);
    }
}

@Injectable()
export class FarmClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerFarm(newFarmParams: NewFarmParams): Observable<FarmVm> {
        let url_ = this.baseUrl + "/farms/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newFarmParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterFarm(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterFarm(<any>response_);
                } catch (e) {
                    return <Observable<FarmVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<FarmVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterFarm(response: HttpResponseBase): Observable<FarmVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FarmVm.fromJS(resultData200) : new FarmVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FarmVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<FarmVm[]> {
        let url_ = this.baseUrl + "/farms/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<FarmVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<FarmVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponseBase): Observable<FarmVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FarmVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FarmVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteById(id: string): Observable<FarmVm[]> {
        let url_ = this.baseUrl + "/farms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteById(<any>response_);
                } catch (e) {
                    return <Observable<FarmVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<FarmVm[]>><any>Observable.throw(response_);
        });
    }

    protected processDeleteById(response: HttpResponseBase): Observable<FarmVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FarmVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FarmVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    updateById(id: string, newFarmParams: NewFarmParams): Observable<FarmVm> {
        let url_ = this.baseUrl + "/farms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newFarmParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateById(<any>response_);
                } catch (e) {
                    return <Observable<FarmVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<FarmVm>><any>Observable.throw(response_);
        });
    }

    protected processUpdateById(response: HttpResponseBase): Observable<FarmVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FarmVm.fromJS(resultData200) : new FarmVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FarmVm>(<any>null);
    }
}

@Injectable()
export class CropClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerCrop(newCropParams: NewCropParams): Observable<CropVm> {
        let url_ = this.baseUrl + "/crops/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newCropParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterCrop(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterCrop(<any>response_);
                } catch (e) {
                    return <Observable<CropVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterCrop(response: HttpResponseBase): Observable<CropVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CropVm.fromJS(resultData200) : new CropVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<CropVm[]> {
        let url_ = this.baseUrl + "/crops/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CropVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponseBase): Observable<CropVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CropVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    getSingleCrop(id: string): Observable<CropVm> {
        let url_ = this.baseUrl + "/crops/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetSingleCrop(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSingleCrop(<any>response_);
                } catch (e) {
                    return <Observable<CropVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm>><any>Observable.throw(response_);
        });
    }

    protected processGetSingleCrop(response: HttpResponseBase): Observable<CropVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CropVm.fromJS(resultData200) : new CropVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm>(<any>null);
    }

    /**
     * @return Ok
     */
    updateCrop(id: string, updateCropParams: NewCropParams): Observable<CropVm> {
        let url_ = this.baseUrl + "/crops/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateCropParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateCrop(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateCrop(<any>response_);
                } catch (e) {
                    return <Observable<CropVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm>><any>Observable.throw(response_);
        });
    }

    protected processUpdateCrop(response: HttpResponseBase): Observable<CropVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CropVm.fromJS(resultData200) : new CropVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteCrop(id: string): Observable<CropVm> {
        let url_ = this.baseUrl + "/crops/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteCrop(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteCrop(<any>response_);
                } catch (e) {
                    return <Observable<CropVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm>><any>Observable.throw(response_);
        });
    }

    protected processDeleteCrop(response: HttpResponseBase): Observable<CropVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CropVm.fromJS(resultData200) : new CropVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm>(<any>null);
    }
}

@Injectable()
export class HarvesterClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerHarvester(newHarvesterParams: NewHarvesterParams): Observable<HarvesterVm> {
        let url_ = this.baseUrl + "/harvesters/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newHarvesterParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterHarvester(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterHarvester(<any>response_);
                } catch (e) {
                    return <Observable<HarvesterVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvesterVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterHarvester(response: HttpResponseBase): Observable<HarvesterVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HarvesterVm.fromJS(resultData200) : new HarvesterVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvesterVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<HarvesterVm[]> {
        let url_ = this.baseUrl + "/harvesters/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<HarvesterVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvesterVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponseBase): Observable<HarvesterVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HarvesterVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvesterVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteHarvesterById(id: string): Observable<HarvesterVm> {
        let url_ = this.baseUrl + "/harvesters/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteHarvesterById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteHarvesterById(<any>response_);
                } catch (e) {
                    return <Observable<HarvesterVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvesterVm>><any>Observable.throw(response_);
        });
    }

    protected processDeleteHarvesterById(response: HttpResponseBase): Observable<HarvesterVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HarvesterVm.fromJS(resultData200) : new HarvesterVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvesterVm>(<any>null);
    }
}

@Injectable()
export class OrganizationClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerOrganization(newOrganizationParams: NewOrganizationParams): Observable<OrganizationVm> {
        let url_ = this.baseUrl + "/organization/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newOrganizationParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterOrganization(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterOrganization(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterOrganization(response: HttpResponseBase): Observable<OrganizationVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationVm.fromJS(resultData200) : new OrganizationVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<OrganizationVm[]> {
        let url_ = this.baseUrl + "/organization/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponseBase): Observable<OrganizationVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    updateOrganization(id: string, newOrganizationParams: NewOrganizationParams): Observable<OrganizationVm> {
        let url_ = this.baseUrl + "/organization/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newOrganizationParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateOrganization(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOrganization(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationVm>><any>Observable.throw(response_);
        });
    }

    protected processUpdateOrganization(response: HttpResponseBase): Observable<OrganizationVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationVm.fromJS(resultData200) : new OrganizationVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationVm>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteOrganization(id: string): Observable<OrganizationVm> {
        let url_ = this.baseUrl + "/organization/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteOrganization(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOrganization(<any>response_);
                } catch (e) {
                    return <Observable<OrganizationVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationVm>><any>Observable.throw(response_);
        });
    }

    protected processDeleteOrganization(response: HttpResponseBase): Observable<OrganizationVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationVm.fromJS(resultData200) : new OrganizationVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationVm>(<any>null);
    }
}

@Injectable()
export class HarvestClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerHarvest(harvestParams: HarvestParams): Observable<HarvestVm> {
        let url_ = this.baseUrl + "/harvests/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(harvestParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterHarvest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegisterHarvest(<any>response_);
                } catch (e) {
                    return <Observable<HarvestVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvestVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterHarvest(response: HttpResponseBase): Observable<HarvestVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HarvestVm.fromJS(resultData200) : new HarvestVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvestVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<HarvestVm[]> {
        let url_ = this.baseUrl + "/harvests/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<HarvestVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvestVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponseBase): Observable<HarvestVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HarvestVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvestVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    getHarvestById(id: string): Observable<HarvestVm> {
        let url_ = this.baseUrl + "/harvests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetHarvestById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHarvestById(<any>response_);
                } catch (e) {
                    return <Observable<HarvestVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvestVm>><any>Observable.throw(response_);
        });
    }

    protected processGetHarvestById(response: HttpResponseBase): Observable<HarvestVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HarvestVm.fromJS(resultData200) : new HarvestVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvestVm>(<any>null);
    }

    /**
     * @return Ok
     */
    updateFarm(id: string, farmId: string): Observable<HarvestVm> {
        let url_ = this.baseUrl + "/harvests/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (farmId === undefined || farmId === null)
            throw new Error("The parameter 'farmId' must be defined and cannot be null.");
        else
            url_ += "farmId=" + encodeURIComponent("" + farmId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateFarm(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateFarm(<any>response_);
                } catch (e) {
                    return <Observable<HarvestVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvestVm>><any>Observable.throw(response_);
        });
    }

    protected processUpdateFarm(response: HttpResponseBase): Observable<HarvestVm> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HarvestVm.fromJS(resultData200) : new HarvestVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvestVm>(<any>null);
    }
}

@Injectable()
export class ReportingClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    getSalesPercentage(percentageType: PercentageType): Observable<PercentageReportResponse> {
        let url_ = this.baseUrl + "/reports/percentage?";
        if (percentageType === undefined || percentageType === null)
            throw new Error("The parameter 'percentageType' must be defined and cannot be null.");
        else
            url_ += "percentageType=" + encodeURIComponent("" + percentageType) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetSalesPercentage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSalesPercentage(<any>response_);
                } catch (e) {
                    return <Observable<PercentageReportResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<PercentageReportResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetSalesPercentage(response: HttpResponseBase): Observable<PercentageReportResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PercentageReportResponse.fromJS(resultData200) : new PercentageReportResponse();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PercentageReportResponse>(<any>null);
    }

    /**
     * @return Ok
     */
    getTotalWeightOrValue(reportParams: ReportByFarm): Observable<ValueReportResponse[]> {
        let url_ = this.baseUrl + "/reports/total";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reportParams);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetTotalWeightOrValue(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTotalWeightOrValue(<any>response_);
                } catch (e) {
                    return <Observable<ValueReportResponse[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<ValueReportResponse[]>><any>Observable.throw(response_);
        });
    }

    protected processGetTotalWeightOrValue(response: HttpResponseBase): Observable<ValueReportResponse[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(ValueReportResponse.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<ValueReportResponse[]>(<any>null);
    }

    /**
     * @return Ok
     */
    getTest(dateStart: moment.Moment, dateEnd: moment.Moment): Observable<HarvestVm[]> {
        let url_ = this.baseUrl + "/reports/test?";
        if (dateStart === undefined || dateStart === null)
            throw new Error("The parameter 'dateStart' must be defined and cannot be null.");
        else
            url_ += "dateStart=" + encodeURIComponent(dateStart ? "" + dateStart.toJSON() : "") + "&";
        if (dateEnd === undefined || dateEnd === null)
            throw new Error("The parameter 'dateEnd' must be defined and cannot be null.");
        else
            url_ += "dateEnd=" + encodeURIComponent(dateEnd ? "" + dateEnd.toJSON() : "") + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetTest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTest(<any>response_);
                } catch (e) {
                    return <Observable<HarvestVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvestVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetTest(response: HttpResponseBase): Observable<HarvestVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HarvestVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvestVm[]>(<any>null);
    }
}

@Injectable()
export class SystemClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    importCrops(): Observable<CropVm[]> {
        let url_ = this.baseUrl + "/system/importCrops";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processImportCrops(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportCrops(<any>response_);
                } catch (e) {
                    return <Observable<CropVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm[]>><any>Observable.throw(response_);
        });
    }

    protected processImportCrops(response: HttpResponseBase): Observable<CropVm[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CropVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm[]>(<any>null);
    }

    /**
     * @dropUser (optional)
     * @return Ok
     */
    clearDatabase(collection: Collection[], dropUser?: boolean | null | undefined): Observable<any> {
        let url_ = this.baseUrl + "/system/clearDatabase?";
        if (collection === undefined || collection === null)
            throw new Error("The parameter 'collection' must be defined and cannot be null.");
        else
            collection && collection.forEach(item => { url_ += "collection=" + encodeURIComponent("" + item) + "&"; });
        if (dropUser !== undefined)
            url_ += "dropUser=" + encodeURIComponent("" + dropUser) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processClearDatabase(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearDatabase(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processClearDatabase(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(responseBlob).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key];
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }
}

export enum UserRole {
    Admin = <any>"Admin",
    User = <any>"User",
}

export class UserVm implements IUserVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    username?: string | null;
    password?: string | null;
    role?: UserRole | null;

    constructor(data?: IUserVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.role = data["role"] !== undefined ? data["role"] : <any>null;
        }
    }

    static fromJS(data: any): UserVm {
        data = typeof data === 'object' ? data : {};
        let result = new UserVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        return data;
    }
}

export interface IUserVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    username?: string | null;
    password?: string | null;
    role?: UserRole | null;
}

export class NewUserParams implements INewUserParams {
    username: string;
    password: string;
    role: UserRole;

    constructor(data?: INewUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.role = data["role"] !== undefined ? data["role"] : <any>null;
        }
    }

    static fromJS(data: any): NewUserParams {
        data = typeof data === 'object' ? data : {};
        let result = new NewUserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        return data;
    }
}

export interface INewUserParams {
    username: string;
    password: string;
    role: UserRole;
}

export class LoginVm implements ILoginVm {
    authToken: string;
    username?: string | null;
    role?: UserRole | null;
    _id?: string | null;

    constructor(data?: ILoginVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authToken = data["authToken"] !== undefined ? data["authToken"] : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.role = data["role"] !== undefined ? data["role"] : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
        }
    }

    static fromJS(data: any): LoginVm {
        data = typeof data === 'object' ? data : {};
        let result = new LoginVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authToken"] = this.authToken !== undefined ? this.authToken : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        return data;
    }
}

export interface ILoginVm {
    authToken: string;
    username?: string | null;
    role?: UserRole | null;
    _id?: string | null;
}

export class LoginParams implements ILoginParams {
    username: string;
    password: string;

    constructor(data?: ILoginParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any): LoginParams {
        data = typeof data === 'object' ? data : {};
        let result = new LoginParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data;
    }
}

export interface ILoginParams {
    username: string;
    password: string;
}

export class CropVm implements ICropVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    name: string;
    variety: string[] = [];
    pricePerPound: number;

    constructor(data?: ICropVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["variety"] && data["variety"].constructor === Array) {
                this.variety = [];
                for (let item of data["variety"])
                    this.variety.push(item);
            }
            this.pricePerPound = data["pricePerPound"] !== undefined ? data["pricePerPound"] : <any>null;
        }
    }

    static fromJS(data: any): CropVm {
        data = typeof data === 'object' ? data : {};
        let result = new CropVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.variety && this.variety.constructor === Array) {
            data["variety"] = [];
            for (let item of this.variety)
                data["variety"].push(item);
        }
        data["pricePerPound"] = this.pricePerPound !== undefined ? this.pricePerPound : <any>null;
        return data;
    }
}

export interface ICropVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    name: string;
    variety: string[];
    pricePerPound: number;
}

export class HarvesterVm implements IHarvesterVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    firstName: string;
    lastName: string;

    constructor(data?: IHarvesterVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
            this.firstName = data["firstName"] !== undefined ? data["firstName"] : <any>null;
            this.lastName = data["lastName"] !== undefined ? data["lastName"] : <any>null;
        }
    }

    static fromJS(data: any): HarvesterVm {
        data = typeof data === 'object' ? data : {};
        let result = new HarvesterVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        return data;
    }
}

export interface IHarvesterVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    firstName: string;
    lastName: string;
}

export enum OrganizationType {
    Purchased = <any>"Purchased",
    Donated = <any>"Donated",
    Internal = <any>"Internal",
}

export class OrganizationVm implements IOrganizationVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    orgType?: OrganizationType | null;
    name?: string | null;

    constructor(data?: IOrganizationVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
            this.orgType = data["orgType"] !== undefined ? data["orgType"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
        }
    }

    static fromJS(data: any): OrganizationVm {
        data = typeof data === 'object' ? data : {};
        let result = new OrganizationVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        data["orgType"] = this.orgType !== undefined ? this.orgType : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        return data;
    }
}

export interface IOrganizationVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    orgType?: OrganizationType | null;
    name?: string | null;
}

export class EntryVm implements IEntryVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    crop: CropVm = new CropVm();
    pounds: number;
    priceTotal: number;
    harvester: HarvesterVm = new HarvesterVm();
    comments: string;
    recipient: OrganizationVm = new OrganizationVm();
    selectedVariety: string;

    constructor(data?: IEntryVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
            this.crop = data["crop"] ? CropVm.fromJS(data["crop"]) : new CropVm();
            this.pounds = data["pounds"] !== undefined ? data["pounds"] : <any>null;
            this.priceTotal = data["priceTotal"] !== undefined ? data["priceTotal"] : <any>null;
            this.harvester = data["harvester"] ? HarvesterVm.fromJS(data["harvester"]) : new HarvesterVm();
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
            this.recipient = data["recipient"] ? OrganizationVm.fromJS(data["recipient"]) : new OrganizationVm();
            this.selectedVariety = data["selectedVariety"] !== undefined ? data["selectedVariety"] : <any>null;
        }
    }

    static fromJS(data: any): EntryVm {
        data = typeof data === 'object' ? data : {};
        let result = new EntryVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        data["crop"] = this.crop ? this.crop.toJSON() : <any>null;
        data["pounds"] = this.pounds !== undefined ? this.pounds : <any>null;
        data["priceTotal"] = this.priceTotal !== undefined ? this.priceTotal : <any>null;
        data["harvester"] = this.harvester ? this.harvester.toJSON() : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>null;
        data["selectedVariety"] = this.selectedVariety !== undefined ? this.selectedVariety : <any>null;
        return data;
    }
}

export interface IEntryVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    crop: CropVm;
    pounds: number;
    priceTotal: number;
    harvester: HarvesterVm;
    comments: string;
    recipient: OrganizationVm;
    selectedVariety: string;
}

export class NewEntryParams implements INewEntryParams {
    pounds: number;
    cropId?: string | null;
    harvesterId?: string | null;
    comments?: string | null;
    recipientId?: string | null;
    selectedVariety?: string | null;

    constructor(data?: INewEntryParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pounds = data["pounds"] !== undefined ? data["pounds"] : <any>null;
            this.cropId = data["cropId"] !== undefined ? data["cropId"] : <any>null;
            this.harvesterId = data["harvesterId"] !== undefined ? data["harvesterId"] : <any>null;
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
            this.recipientId = data["recipientId"] !== undefined ? data["recipientId"] : <any>null;
            this.selectedVariety = data["selectedVariety"] !== undefined ? data["selectedVariety"] : <any>null;
        }
    }

    static fromJS(data: any): NewEntryParams {
        data = typeof data === 'object' ? data : {};
        let result = new NewEntryParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pounds"] = this.pounds !== undefined ? this.pounds : <any>null;
        data["cropId"] = this.cropId !== undefined ? this.cropId : <any>null;
        data["harvesterId"] = this.harvesterId !== undefined ? this.harvesterId : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["recipientId"] = this.recipientId !== undefined ? this.recipientId : <any>null;
        data["selectedVariety"] = this.selectedVariety !== undefined ? this.selectedVariety : <any>null;
        return data;
    }
}

export interface INewEntryParams {
    pounds: number;
    cropId?: string | null;
    harvesterId?: string | null;
    comments?: string | null;
    recipientId?: string | null;
    selectedVariety?: string | null;
}

export class FarmVm implements IFarmVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    name: string;
    lat: number;
    lng: number;

    constructor(data?: IFarmVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.lat = data["lat"] !== undefined ? data["lat"] : <any>null;
            this.lng = data["lng"] !== undefined ? data["lng"] : <any>null;
        }
    }

    static fromJS(data: any): FarmVm {
        data = typeof data === 'object' ? data : {};
        let result = new FarmVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["lat"] = this.lat !== undefined ? this.lat : <any>null;
        data["lng"] = this.lng !== undefined ? this.lng : <any>null;
        return data;
    }
}

export interface IFarmVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    name: string;
    lat: number;
    lng: number;
}

export class HarvestVm implements IHarvestVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    farm: FarmVm = new FarmVm();
    entries: EntryVm[] = [];

    constructor(data?: IHarvestVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
            this.farm = data["farm"] ? FarmVm.fromJS(data["farm"]) : new FarmVm();
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [];
                for (let item of data["entries"])
                    this.entries.push(EntryVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): HarvestVm {
        data = typeof data === 'object' ? data : {};
        let result = new HarvestVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        data["farm"] = this.farm ? this.farm.toJSON() : <any>null;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        return data;
    }
}

export interface IHarvestVm {
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
    farm: FarmVm;
    entries: EntryVm[];
}

export class NewFarmParams implements INewFarmParams {
    name: string;
    lat: number;
    lng: number;

    constructor(data?: INewFarmParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.lat = data["lat"] !== undefined ? data["lat"] : <any>null;
            this.lng = data["lng"] !== undefined ? data["lng"] : <any>null;
        }
    }

    static fromJS(data: any): NewFarmParams {
        data = typeof data === 'object' ? data : {};
        let result = new NewFarmParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["lat"] = this.lat !== undefined ? this.lat : <any>null;
        data["lng"] = this.lng !== undefined ? this.lng : <any>null;
        return data;
    }
}

export interface INewFarmParams {
    name: string;
    lat: number;
    lng: number;
}

export class NewCropParams implements INewCropParams {
    name: string;
    variety: string[] = [];
    pricePerPound: number;

    constructor(data?: INewCropParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["variety"] && data["variety"].constructor === Array) {
                this.variety = [];
                for (let item of data["variety"])
                    this.variety.push(item);
            }
            this.pricePerPound = data["pricePerPound"] !== undefined ? data["pricePerPound"] : <any>null;
        }
    }

    static fromJS(data: any): NewCropParams {
        data = typeof data === 'object' ? data : {};
        let result = new NewCropParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.variety && this.variety.constructor === Array) {
            data["variety"] = [];
            for (let item of this.variety)
                data["variety"].push(item);
        }
        data["pricePerPound"] = this.pricePerPound !== undefined ? this.pricePerPound : <any>null;
        return data;
    }
}

export interface INewCropParams {
    name: string;
    variety: string[];
    pricePerPound: number;
}

export class NewHarvesterParams implements INewHarvesterParams {
    lastName: string;
    firstName: string;

    constructor(data?: INewHarvesterParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lastName = data["lastName"] !== undefined ? data["lastName"] : <any>null;
            this.firstName = data["firstName"] !== undefined ? data["firstName"] : <any>null;
        }
    }

    static fromJS(data: any): NewHarvesterParams {
        data = typeof data === 'object' ? data : {};
        let result = new NewHarvesterParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        return data;
    }
}

export interface INewHarvesterParams {
    lastName: string;
    firstName: string;
}

export class NewOrganizationParams implements INewOrganizationParams {
    name: string;
    orgType?: OrganizationType | null;

    constructor(data?: INewOrganizationParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.orgType = data["orgType"] !== undefined ? data["orgType"] : <any>null;
        }
    }

    static fromJS(data: any): NewOrganizationParams {
        data = typeof data === 'object' ? data : {};
        let result = new NewOrganizationParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["orgType"] = this.orgType !== undefined ? this.orgType : <any>null;
        return data;
    }
}

export interface INewOrganizationParams {
    name: string;
    orgType?: OrganizationType | null;
}

export class HarvestParams implements IHarvestParams {
    farmId: string;
    entriesIds?: string[] | null;
    harvestId?: string | null;

    constructor(data?: IHarvestParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.farmId = data["farmId"] !== undefined ? data["farmId"] : <any>null;
            if (data["entriesIds"] && data["entriesIds"].constructor === Array) {
                this.entriesIds = [];
                for (let item of data["entriesIds"])
                    this.entriesIds.push(item);
            }
            this.harvestId = data["harvestId"] !== undefined ? data["harvestId"] : <any>null;
        }
    }

    static fromJS(data: any): HarvestParams {
        data = typeof data === 'object' ? data : {};
        let result = new HarvestParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["farmId"] = this.farmId !== undefined ? this.farmId : <any>null;
        if (this.entriesIds && this.entriesIds.constructor === Array) {
            data["entriesIds"] = [];
            for (let item of this.entriesIds)
                data["entriesIds"].push(item);
        }
        data["harvestId"] = this.harvestId !== undefined ? this.harvestId : <any>null;
        return data;
    }
}

export interface IHarvestParams {
    farmId: string;
    entriesIds?: string[] | null;
    harvestId?: string | null;
}

export enum PercentageReportType {
    Purchased = <any>"Purchased",
    Donated = <any>"Donated",
}

export class PercentageReportResponse implements IPercentageReportResponse {
    type?: PercentageReportType | null;
    createdOn?: moment.Moment | null;
    percentage?: string | null;

    constructor(data?: IPercentageReportResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.percentage = data["percentage"] !== undefined ? data["percentage"] : <any>null;
        }
    }

    static fromJS(data: any): PercentageReportResponse {
        data = typeof data === 'object' ? data : {};
        let result = new PercentageReportResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["percentage"] = this.percentage !== undefined ? this.percentage : <any>null;
        return data;
    }
}

export interface IPercentageReportResponse {
    type?: PercentageReportType | null;
    createdOn?: moment.Moment | null;
    percentage?: string | null;
}

export class ValueReportResponse implements IValueReportResponse {
    farmName: string;
    value: number;

    constructor(data?: IValueReportResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.farmName = data["farmName"] !== undefined ? data["farmName"] : <any>null;
            this.value = data["value"] !== undefined ? data["value"] : <any>null;
        }
    }

    static fromJS(data: any): ValueReportResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ValueReportResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["farmName"] = this.farmName !== undefined ? this.farmName : <any>null;
        data["value"] = this.value !== undefined ? this.value : <any>null;
        return data;
    }
}

export interface IValueReportResponse {
    farmName: string;
    value: number;
}

export enum WeightValueReportType {
    Weight = <any>"Weight",
    Value = <any>"Value",
}

export class ReportByFarm implements IReportByFarm {
    valueReportType: WeightValueReportType;
    dateRange?: moment.Moment[] | null;

    constructor(data?: IReportByFarm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.valueReportType = data["valueReportType"] !== undefined ? data["valueReportType"] : <any>null;
            if (data["dateRange"] && data["dateRange"].constructor === Array) {
                this.dateRange = [];
                for (let item of data["dateRange"])
                    this.dateRange.push(moment(item));
            }
        }
    }

    static fromJS(data: any): ReportByFarm {
        data = typeof data === 'object' ? data : {};
        let result = new ReportByFarm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["valueReportType"] = this.valueReportType !== undefined ? this.valueReportType : <any>null;
        if (this.dateRange && this.dateRange.constructor === Array) {
            data["dateRange"] = [];
            for (let item of this.dateRange)
                data["dateRange"].push(item.toISOString());
        }
        return data;
    }
}

export interface IReportByFarm {
    valueReportType: WeightValueReportType;
    dateRange?: moment.Moment[] | null;
}

export class ClearDbResponse implements IClearDbResponse {
    result: any = {};
    connection?: any | null;
    deletedCount?: number | null;
    collection?: string | null;

    constructor(data?: IClearDbResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            if (data["result"]) {
                this.result = {};
                for (let key in data["result"]) {
                    if (data["result"].hasOwnProperty(key))
                        this.result[key] = data["result"][key];
                }
            }
            if (data["connection"]) {
                this.connection = {};
                for (let key in data["connection"]) {
                    if (data["connection"].hasOwnProperty(key))
                        this.connection[key] = data["connection"][key];
                }
            }
            this.deletedCount = data["deletedCount"] !== undefined ? data["deletedCount"] : <any>null;
            this.collection = data["collection"] !== undefined ? data["collection"] : <any>null;
        }
    }

    static fromJS(data: any): ClearDbResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ClearDbResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.result) {
            data["result"] = {};
            for (let key in this.result) {
                if (this.result.hasOwnProperty(key))
                    data["result"][key] = this.result[key] !== undefined ? this.result[key] : <any>null;
            }
        }
        if (this.connection) {
            data["connection"] = {};
            for (let key in this.connection) {
                if (this.connection.hasOwnProperty(key))
                    data["connection"][key] = this.connection[key] !== undefined ? this.connection[key] : <any>null;
            }
        }
        data["deletedCount"] = this.deletedCount !== undefined ? this.deletedCount : <any>null;
        data["collection"] = this.collection !== undefined ? this.collection : <any>null;
        return data;
    }
}

export interface IClearDbResponse {
    result: any;
    connection?: any | null;
    deletedCount?: number | null;
    collection?: string | null;
}

export enum PercentageType {
    Purchased = <any>"Purchased",
    Donated = <any>"Donated",
}

export enum Collection {
    Crops = <any>"crops",
    Entries = <any>"entries",
    Farms = <any>"farms",
    Harvesters = <any>"harvesters",
    Harvests = <any>"harvests",
    Organizations = <any>"organizations",
    Users = <any>"users",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = function() {
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob);
        }
    });
}
