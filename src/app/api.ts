/* tslint:disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v11.11.1.0 (NJsonSchema v9.9.11.0 (Newtonsoft.Json v9.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import 'rxjs/add/observable/fromPromise';
import 'rxjs/add/observable/of';
import 'rxjs/add/observable/throw';
import 'rxjs/add/operator/map';
import 'rxjs/add/operator/toPromise';
import 'rxjs/add/operator/mergeMap';
import 'rxjs/add/operator/catch';

import { Observable } from 'rxjs/Observable';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpParams } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class UserClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerUser(newUserParams: INewUserParams): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newUserParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterUser(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegisterUser(response_);
                } catch (e) {
                    return <Observable<UserVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterUser(response: HttpResponse<Blob>): Observable<UserVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getUserByUsername(username: string): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/{username}";
        if (username === undefined || username === null)
            throw new Error("The parameter 'username' must be defined.");
        url_ = url_.replace("{username}", encodeURIComponent("" + username)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetUserByUsername(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetUserByUsername(response_);
                } catch (e) {
                    return <Observable<UserVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm>><any>Observable.throw(response_);
        });
    }

    protected processGetUserByUsername(response: HttpResponse<Blob>): Observable<UserVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm>(<any>null);
    }

    /**
     * @return Ok
     */
    login(loginParams: ILoginParams): Observable<LoginVm> {
        let url_ = this.baseUrl + "/users/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(loginParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processLogin(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processLogin(response_);
                } catch (e) {
                    return <Observable<LoginVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<LoginVm>><any>Observable.throw(response_);
        });
    }

    protected processLogin(response: HttpResponse<Blob>): Observable<LoginVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? LoginVm.fromJS(resultData200) : new LoginVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<LoginVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAllUsers(): Observable<UserVm[]> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAllUsers(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetAllUsers(response_);
                } catch (e) {
                    return <Observable<UserVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAllUsers(response: HttpResponse<Blob>): Observable<UserVm[]> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(UserVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteUserById(id: string): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteUserById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDeleteUserById(response_);
                } catch (e) {
                    return <Observable<UserVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm>><any>Observable.throw(response_);
        });
    }

    protected processDeleteUserById(response: HttpResponse<Blob>): Observable<UserVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm>(<any>null);
    }

    /**
     * @return Ok
     */
    udpateUserById(id: string, updateUserParams: INewUserParams): Observable<UserVm> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateUserParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUdpateUserById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUdpateUserById(response_);
                } catch (e) {
                    return <Observable<UserVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<UserVm>><any>Observable.throw(response_);
        });
    }

    protected processUdpateUserById(response: HttpResponse<Blob>): Observable<UserVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? UserVm.fromJS(resultData200) : new UserVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<UserVm>(<any>null);
    }
}

@Injectable()
export class EntryClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerEntry(newEntryParams: INewEntryParams): Observable<EntryVm> {
        let url_ = this.baseUrl + "/entries/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newEntryParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterEntry(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegisterEntry(response_);
                } catch (e) {
                    return <Observable<EntryVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<EntryVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterEntry(response: HttpResponse<Blob>): Observable<EntryVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EntryVm.fromJS(resultData200) : new EntryVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EntryVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<EntryVm[]> {
        let url_ = this.baseUrl + "/entries/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<EntryVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<EntryVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponse<Blob>): Observable<EntryVm[]> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(EntryVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EntryVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    getSingleEntry(id: string): Observable<EntryVm> {
        let url_ = this.baseUrl + "/entries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetSingleEntry(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetSingleEntry(response_);
                } catch (e) {
                    return <Observable<EntryVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<EntryVm>><any>Observable.throw(response_);
        });
    }

    protected processGetSingleEntry(response: HttpResponse<Blob>): Observable<EntryVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EntryVm.fromJS(resultData200) : new EntryVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EntryVm>(<any>null);
    }

    /**
     * @return Ok
     */
    updateEntry(id: string, updatedEntryParams: INewEntryParams): Observable<EntryVm> {
        let url_ = this.baseUrl + "/entries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updatedEntryParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateEntry(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdateEntry(response_);
                } catch (e) {
                    return <Observable<EntryVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<EntryVm>><any>Observable.throw(response_);
        });
    }

    protected processUpdateEntry(response: HttpResponse<Blob>): Observable<EntryVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EntryVm.fromJS(resultData200) : new EntryVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EntryVm>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteEntry(id: string): Observable<EntryVm> {
        let url_ = this.baseUrl + "/entries/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteEntry(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDeleteEntry(response_);
                } catch (e) {
                    return <Observable<EntryVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<EntryVm>><any>Observable.throw(response_);
        });
    }

    protected processDeleteEntry(response: HttpResponse<Blob>): Observable<EntryVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? EntryVm.fromJS(resultData200) : new EntryVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<EntryVm>(<any>null);
    }
}

@Injectable()
export class FarmClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerFarm(newFarmParams: INewFarmParams): Observable<FarmVm> {
        let url_ = this.baseUrl + "/farms/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newFarmParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterFarm(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegisterFarm(response_);
                } catch (e) {
                    return <Observable<FarmVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<FarmVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterFarm(response: HttpResponse<Blob>): Observable<FarmVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FarmVm.fromJS(resultData200) : new FarmVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FarmVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<FarmVm[]> {
        let url_ = this.baseUrl + "/farms/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<FarmVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<FarmVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponse<Blob>): Observable<FarmVm[]> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FarmVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FarmVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteById(id: string): Observable<FarmVm[]> {
        let url_ = this.baseUrl + "/farms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDeleteById(response_);
                } catch (e) {
                    return <Observable<FarmVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<FarmVm[]>><any>Observable.throw(response_);
        });
    }

    protected processDeleteById(response: HttpResponse<Blob>): Observable<FarmVm[]> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(FarmVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FarmVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    updateById(id: string, newFarmParams: INewFarmParams): Observable<FarmVm> {
        let url_ = this.baseUrl + "/farms/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newFarmParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdateById(response_);
                } catch (e) {
                    return <Observable<FarmVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<FarmVm>><any>Observable.throw(response_);
        });
    }

    protected processUpdateById(response: HttpResponse<Blob>): Observable<FarmVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? FarmVm.fromJS(resultData200) : new FarmVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<FarmVm>(<any>null);
    }
}

@Injectable()
export class CropClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerCrop(newCropParams: INewCropParams): Observable<CropVm> {
        let url_ = this.baseUrl + "/crops/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newCropParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterCrop(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegisterCrop(response_);
                } catch (e) {
                    return <Observable<CropVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterCrop(response: HttpResponse<Blob>): Observable<CropVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CropVm.fromJS(resultData200) : new CropVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<CropVm[]> {
        let url_ = this.baseUrl + "/crops/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<CropVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponse<Blob>): Observable<CropVm[]> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CropVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    getSingleCrop(id: string): Observable<CropVm> {
        let url_ = this.baseUrl + "/crops/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetSingleCrop(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetSingleCrop(response_);
                } catch (e) {
                    return <Observable<CropVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm>><any>Observable.throw(response_);
        });
    }

    protected processGetSingleCrop(response: HttpResponse<Blob>): Observable<CropVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CropVm.fromJS(resultData200) : new CropVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm>(<any>null);
    }

    /**
     * @return Ok
     */
    updateCrop(id: string, updateCropParams: INewCropParams): Observable<CropVm> {
        let url_ = this.baseUrl + "/crops/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(updateCropParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateCrop(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdateCrop(response_);
                } catch (e) {
                    return <Observable<CropVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm>><any>Observable.throw(response_);
        });
    }

    protected processUpdateCrop(response: HttpResponse<Blob>): Observable<CropVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CropVm.fromJS(resultData200) : new CropVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteCrop(id: string): Observable<CropVm> {
        let url_ = this.baseUrl + "/crops/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteCrop(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDeleteCrop(response_);
                } catch (e) {
                    return <Observable<CropVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm>><any>Observable.throw(response_);
        });
    }

    protected processDeleteCrop(response: HttpResponse<Blob>): Observable<CropVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? CropVm.fromJS(resultData200) : new CropVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm>(<any>null);
    }
}

@Injectable()
export class HarvesterClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerHarvester(newHarvesterParams: INewHarvesterParams): Observable<HarvesterVm> {
        let url_ = this.baseUrl + "/harvesters/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newHarvesterParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterHarvester(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegisterHarvester(response_);
                } catch (e) {
                    return <Observable<HarvesterVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvesterVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterHarvester(response: HttpResponse<Blob>): Observable<HarvesterVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HarvesterVm.fromJS(resultData200) : new HarvesterVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvesterVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<HarvesterVm[]> {
        let url_ = this.baseUrl + "/harvesters/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<HarvesterVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvesterVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponse<Blob>): Observable<HarvesterVm[]> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HarvesterVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvesterVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteHarvesterById(id: string): Observable<HarvesterVm> {
        let url_ = this.baseUrl + "/harvesters/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteHarvesterById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDeleteHarvesterById(response_);
                } catch (e) {
                    return <Observable<HarvesterVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvesterVm>><any>Observable.throw(response_);
        });
    }

    protected processDeleteHarvesterById(response: HttpResponse<Blob>): Observable<HarvesterVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HarvesterVm.fromJS(resultData200) : new HarvesterVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvesterVm>(<any>null);
    }
}

@Injectable()
export class OrganizationClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerOrganization(newOrganizationParams: INewOrganizationParams): Observable<OrganizationVm> {
        let url_ = this.baseUrl + "/organization/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newOrganizationParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterOrganization(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegisterOrganization(response_);
                } catch (e) {
                    return <Observable<OrganizationVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterOrganization(response: HttpResponse<Blob>): Observable<OrganizationVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationVm.fromJS(resultData200) : new OrganizationVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<OrganizationVm[]> {
        let url_ = this.baseUrl + "/organization/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<OrganizationVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponse<Blob>): Observable<OrganizationVm[]> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(OrganizationVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    updateOrganization(id: string, newOrganizationParams: INewOrganizationParams): Observable<OrganizationVm> {
        let url_ = this.baseUrl + "/organization/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(newOrganizationParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("put", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processUpdateOrganization(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processUpdateOrganization(response_);
                } catch (e) {
                    return <Observable<OrganizationVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationVm>><any>Observable.throw(response_);
        });
    }

    protected processUpdateOrganization(response: HttpResponse<Blob>): Observable<OrganizationVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationVm.fromJS(resultData200) : new OrganizationVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationVm>(<any>null);
    }

    /**
     * @return Ok
     */
    deleteOrganization(id: string): Observable<OrganizationVm> {
        let url_ = this.baseUrl + "/organization/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("delete", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processDeleteOrganization(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processDeleteOrganization(response_);
                } catch (e) {
                    return <Observable<OrganizationVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<OrganizationVm>><any>Observable.throw(response_);
        });
    }

    protected processDeleteOrganization(response: HttpResponse<Blob>): Observable<OrganizationVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? OrganizationVm.fromJS(resultData200) : new OrganizationVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<OrganizationVm>(<any>null);
    }
}

@Injectable()
export class HarvestClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    registerHarvest(harvestParams: IHarvestParams): Observable<HarvestVm> {
        let url_ = this.baseUrl + "/harvests/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(harvestParams);
        
        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("post", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processRegisterHarvest(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processRegisterHarvest(response_);
                } catch (e) {
                    return <Observable<HarvestVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvestVm>><any>Observable.throw(response_);
        });
    }

    protected processRegisterHarvest(response: HttpResponse<Blob>): Observable<HarvestVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HarvestVm.fromJS(resultData200) : new HarvestVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvestVm>(<any>null);
    }

    /**
     * @return Ok
     */
    getAll(): Observable<HarvestVm[]> {
        let url_ = this.baseUrl + "/harvests/getAll";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetAll(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetAll(response_);
                } catch (e) {
                    return <Observable<HarvestVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvestVm[]>><any>Observable.throw(response_);
        });
    }

    protected processGetAll(response: HttpResponse<Blob>): Observable<HarvestVm[]> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(HarvestVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvestVm[]>(<any>null);
    }

    /**
     * @return Ok
     */
    getHarvestById(id: string): Observable<HarvestVm> {
        let url_ = this.baseUrl + "/harvests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetHarvestById(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetHarvestById(response_);
                } catch (e) {
                    return <Observable<HarvestVm>><any>Observable.throw(e);
                }
            } else
                return <Observable<HarvestVm>><any>Observable.throw(response_);
        });
    }

    protected processGetHarvestById(response: HttpResponse<Blob>): Observable<HarvestVm> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? HarvestVm.fromJS(resultData200) : new HarvestVm();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<HarvestVm>(<any>null);
    }
}

@Injectable()
export class ReportingClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    getSalesPercentage(percentageType: string): Observable<PercentageReportResponse> {
        let url_ = this.baseUrl + "/reports/percentage?";
        if (percentageType === undefined || percentageType === null)
            throw new Error("The parameter 'percentageType' must be defined and cannot be null.");
        else
            url_ += "percentageType=" + encodeURIComponent("" + percentageType) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetSalesPercentage(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetSalesPercentage(response_);
                } catch (e) {
                    return <Observable<PercentageReportResponse>><any>Observable.throw(e);
                }
            } else
                return <Observable<PercentageReportResponse>><any>Observable.throw(response_);
        });
    }

    protected processGetSalesPercentage(response: HttpResponse<Blob>): Observable<PercentageReportResponse> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 ? PercentageReportResponse.fromJS(resultData200) : new PercentageReportResponse();
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<PercentageReportResponse>(<any>null);
    }

    /**
     * @return Ok
     */
    getTotalWeightOrValue(weightOrValue: string): Observable<any> {
        let url_ = this.baseUrl + "/reports/total?";
        if (weightOrValue === undefined || weightOrValue === null)
            throw new Error("The parameter 'weightOrValue' must be defined and cannot be null.");
        else
            url_ += "weightOrValue=" + encodeURIComponent("" + weightOrValue) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processGetTotalWeightOrValue(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processGetTotalWeightOrValue(response_);
                } catch (e) {
                    return <Observable<any>><any>Observable.throw(e);
                }
            } else
                return <Observable<any>><any>Observable.throw(response_);
        });
    }

    protected processGetTotalWeightOrValue(response: HttpResponse<Blob>): Observable<any> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200) {
                result200 = {};
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200[key] = resultData200[key] !== undefined ? resultData200[key] : <any>null;
                }
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<any>(<any>null);
    }
}

@Injectable()
export class SystemClient extends BaseClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        super();
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * @return Ok
     */
    importCrops(): Observable<CropVm[]> {
        let url_ = this.baseUrl + "/system/importCrops";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json", 
                "Accept": "application/json"
            })
        };

        return Observable.fromPromise(this.transformOptions(options_)).flatMap(transformedOptions_ => {
            return this.http.request("get", url_, transformedOptions_);
        }).flatMap((response_: any) => {
            return this.processImportCrops(response_);
        }).catch((response_: any) => {
            if (response_ instanceof HttpResponse) {
                try {
                    return this.processImportCrops(response_);
                } catch (e) {
                    return <Observable<CropVm[]>><any>Observable.throw(e);
                }
            } else
                return <Observable<CropVm[]>><any>Observable.throw(response_);
        });
    }

    protected processImportCrops(response: HttpResponse<Blob>): Observable<CropVm[]> {
        const status = response.status; 

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }};
        if (status === 200) {
            return blobToText(response.body).flatMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (resultData200 && resultData200.constructor === Array) {
                result200 = [];
                for (let item of resultData200)
                    result200.push(CropVm.fromJS(item));
            }
            return Observable.of(result200);
            });
        } else if (status !== 200 && status !== 204) {
            return blobToText(response.body).flatMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            });
        }
        return Observable.of<CropVm[]>(<any>null);
    }
}

export enum UserRole {
    Admin = <any>"Admin", 
    User = <any>"User", 
}

export class UserVm implements IUserVm {
    username?: string | null;
    password?: string | null;
    role?: UserRole | null;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;

    constructor(data?: IUserVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.role = data["role"] !== undefined ? data["role"] : <any>null;
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
        }
    }

    static fromJS(data: any): UserVm {
        let result = new UserVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        return data; 
    }
}

export interface IUserVm {
    username?: string | null;
    password?: string | null;
    role?: UserRole | null;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
}

export class INewUserParams implements IINewUserParams {
    username: string;
    password: string;
    role: UserRole;

    constructor(data?: IINewUserParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
            this.role = data["role"] !== undefined ? data["role"] : <any>null;
        }
    }

    static fromJS(data: any): INewUserParams {
        let result = new INewUserParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        return data; 
    }
}

export interface IINewUserParams {
    username: string;
    password: string;
    role: UserRole;
}

export class LoginVm implements ILoginVm {
    authToken: string;
    username?: string | null;
    role?: UserRole | null;
    _id?: string | null;

    constructor(data?: ILoginVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.authToken = data["authToken"] !== undefined ? data["authToken"] : <any>null;
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.role = data["role"] !== undefined ? data["role"] : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
        }
    }

    static fromJS(data: any): LoginVm {
        let result = new LoginVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["authToken"] = this.authToken !== undefined ? this.authToken : <any>null;
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["role"] = this.role !== undefined ? this.role : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        return data; 
    }
}

export interface ILoginVm {
    authToken: string;
    username?: string | null;
    role?: UserRole | null;
    _id?: string | null;
}

export class ILoginParams implements IILoginParams {
    username: string;
    password: string;

    constructor(data?: IILoginParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.username = data["username"] !== undefined ? data["username"] : <any>null;
            this.password = data["password"] !== undefined ? data["password"] : <any>null;
        }
    }

    static fromJS(data: any): ILoginParams {
        let result = new ILoginParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username !== undefined ? this.username : <any>null;
        data["password"] = this.password !== undefined ? this.password : <any>null;
        return data; 
    }
}

export interface IILoginParams {
    username: string;
    password: string;
}

export class CropVm implements ICropVm {
    name: string;
    variety: string[] = [];
    pricePerPound: number;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;

    constructor(data?: ICropVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["variety"] && data["variety"].constructor === Array) {
                this.variety = [];
                for (let item of data["variety"])
                    this.variety.push(item);
            }
            this.pricePerPound = data["pricePerPound"] !== undefined ? data["pricePerPound"] : <any>null;
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
        }
    }

    static fromJS(data: any): CropVm {
        let result = new CropVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.variety && this.variety.constructor === Array) {
            data["variety"] = [];
            for (let item of this.variety)
                data["variety"].push(item);
        }
        data["pricePerPound"] = this.pricePerPound !== undefined ? this.pricePerPound : <any>null;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        return data; 
    }
}

export interface ICropVm {
    name: string;
    variety: string[];
    pricePerPound: number;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
}

export class HarvesterVm implements IHarvesterVm {
    firstName: string;
    lastName: string;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;

    constructor(data?: IHarvesterVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.firstName = data["firstName"] !== undefined ? data["firstName"] : <any>null;
            this.lastName = data["lastName"] !== undefined ? data["lastName"] : <any>null;
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
        }
    }

    static fromJS(data: any): HarvesterVm {
        let result = new HarvesterVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        return data; 
    }
}

export interface IHarvesterVm {
    firstName: string;
    lastName: string;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
}

export enum OrganizationType {
    Purchased = <any>"Purchased", 
    Donated = <any>"Donated", 
    Internal = <any>"Internal", 
}

export class OrganizationVm implements IOrganizationVm {
    orgType?: OrganizationType | null;
    name?: string | null;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;

    constructor(data?: IOrganizationVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.orgType = data["orgType"] !== undefined ? data["orgType"] : <any>null;
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
        }
    }

    static fromJS(data: any): OrganizationVm {
        let result = new OrganizationVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["orgType"] = this.orgType !== undefined ? this.orgType : <any>null;
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        return data; 
    }
}

export interface IOrganizationVm {
    orgType?: OrganizationType | null;
    name?: string | null;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
}

export class EntryVm implements IEntryVm {
    crop: CropVm = new CropVm();
    pounds: number;
    priceTotal: number;
    harvester: HarvesterVm = new HarvesterVm();
    comments: string;
    recipient: OrganizationVm = new OrganizationVm();
    selectedVariety: string;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;

    constructor(data?: IEntryVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.crop = data["crop"] ? CropVm.fromJS(data["crop"]) : new CropVm();
            this.pounds = data["pounds"] !== undefined ? data["pounds"] : <any>null;
            this.priceTotal = data["priceTotal"] !== undefined ? data["priceTotal"] : <any>null;
            this.harvester = data["harvester"] ? HarvesterVm.fromJS(data["harvester"]) : new HarvesterVm();
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
            this.recipient = data["recipient"] ? OrganizationVm.fromJS(data["recipient"]) : new OrganizationVm();
            this.selectedVariety = data["selectedVariety"] !== undefined ? data["selectedVariety"] : <any>null;
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
        }
    }

    static fromJS(data: any): EntryVm {
        let result = new EntryVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["crop"] = this.crop ? this.crop.toJSON() : <any>null;
        data["pounds"] = this.pounds !== undefined ? this.pounds : <any>null;
        data["priceTotal"] = this.priceTotal !== undefined ? this.priceTotal : <any>null;
        data["harvester"] = this.harvester ? this.harvester.toJSON() : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["recipient"] = this.recipient ? this.recipient.toJSON() : <any>null;
        data["selectedVariety"] = this.selectedVariety !== undefined ? this.selectedVariety : <any>null;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        return data; 
    }
}

export interface IEntryVm {
    crop: CropVm;
    pounds: number;
    priceTotal: number;
    harvester: HarvesterVm;
    comments: string;
    recipient: OrganizationVm;
    selectedVariety: string;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
}

export class INewEntryParams implements IINewEntryParams {
    pounds: number;
    cropId?: string | null;
    harvesterId?: string | null;
    comments?: string | null;
    recipientId?: string | null;
    selectedVariety?: string | null;

    constructor(data?: IINewEntryParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.pounds = data["pounds"] !== undefined ? data["pounds"] : <any>null;
            this.cropId = data["cropId"] !== undefined ? data["cropId"] : <any>null;
            this.harvesterId = data["harvesterId"] !== undefined ? data["harvesterId"] : <any>null;
            this.comments = data["comments"] !== undefined ? data["comments"] : <any>null;
            this.recipientId = data["recipientId"] !== undefined ? data["recipientId"] : <any>null;
            this.selectedVariety = data["selectedVariety"] !== undefined ? data["selectedVariety"] : <any>null;
        }
    }

    static fromJS(data: any): INewEntryParams {
        let result = new INewEntryParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["pounds"] = this.pounds !== undefined ? this.pounds : <any>null;
        data["cropId"] = this.cropId !== undefined ? this.cropId : <any>null;
        data["harvesterId"] = this.harvesterId !== undefined ? this.harvesterId : <any>null;
        data["comments"] = this.comments !== undefined ? this.comments : <any>null;
        data["recipientId"] = this.recipientId !== undefined ? this.recipientId : <any>null;
        data["selectedVariety"] = this.selectedVariety !== undefined ? this.selectedVariety : <any>null;
        return data; 
    }
}

export interface IINewEntryParams {
    pounds: number;
    cropId?: string | null;
    harvesterId?: string | null;
    comments?: string | null;
    recipientId?: string | null;
    selectedVariety?: string | null;
}

export class FarmVm implements IFarmVm {
    name: string;
    lat: number;
    lng: number;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;

    constructor(data?: IFarmVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.lat = data["lat"] !== undefined ? data["lat"] : <any>null;
            this.lng = data["lng"] !== undefined ? data["lng"] : <any>null;
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
        }
    }

    static fromJS(data: any): FarmVm {
        let result = new FarmVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["lat"] = this.lat !== undefined ? this.lat : <any>null;
        data["lng"] = this.lng !== undefined ? this.lng : <any>null;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        return data; 
    }
}

export interface IFarmVm {
    name: string;
    lat: number;
    lng: number;
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
}

export class INewFarmParams implements IINewFarmParams {
    name: string;
    lat: number;
    lng: number;

    constructor(data?: IINewFarmParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.lat = data["lat"] !== undefined ? data["lat"] : <any>null;
            this.lng = data["lng"] !== undefined ? data["lng"] : <any>null;
        }
    }

    static fromJS(data: any): INewFarmParams {
        let result = new INewFarmParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["lat"] = this.lat !== undefined ? this.lat : <any>null;
        data["lng"] = this.lng !== undefined ? this.lng : <any>null;
        return data; 
    }
}

export interface IINewFarmParams {
    name: string;
    lat: number;
    lng: number;
}

export class INewCropParams implements IINewCropParams {
    name: string;
    variety: string[] = [];
    pricePerPound: number;

    constructor(data?: IINewCropParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            if (data["variety"] && data["variety"].constructor === Array) {
                this.variety = [];
                for (let item of data["variety"])
                    this.variety.push(item);
            }
            this.pricePerPound = data["pricePerPound"] !== undefined ? data["pricePerPound"] : <any>null;
        }
    }

    static fromJS(data: any): INewCropParams {
        let result = new INewCropParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        if (this.variety && this.variety.constructor === Array) {
            data["variety"] = [];
            for (let item of this.variety)
                data["variety"].push(item);
        }
        data["pricePerPound"] = this.pricePerPound !== undefined ? this.pricePerPound : <any>null;
        return data; 
    }
}

export interface IINewCropParams {
    name: string;
    variety: string[];
    pricePerPound: number;
}

export class INewHarvesterParams implements IINewHarvesterParams {
    lastName: string;
    firstName: string;

    constructor(data?: IINewHarvesterParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.lastName = data["lastName"] !== undefined ? data["lastName"] : <any>null;
            this.firstName = data["firstName"] !== undefined ? data["firstName"] : <any>null;
        }
    }

    static fromJS(data: any): INewHarvesterParams {
        let result = new INewHarvesterParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["lastName"] = this.lastName !== undefined ? this.lastName : <any>null;
        data["firstName"] = this.firstName !== undefined ? this.firstName : <any>null;
        return data; 
    }
}

export interface IINewHarvesterParams {
    lastName: string;
    firstName: string;
}

export class INewOrganizationParams implements IINewOrganizationParams {
    name: string;
    orgType?: OrganizationType | null;

    constructor(data?: IINewOrganizationParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.name = data["name"] !== undefined ? data["name"] : <any>null;
            this.orgType = data["orgType"] !== undefined ? data["orgType"] : <any>null;
        }
    }

    static fromJS(data: any): INewOrganizationParams {
        let result = new INewOrganizationParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name !== undefined ? this.name : <any>null;
        data["orgType"] = this.orgType !== undefined ? this.orgType : <any>null;
        return data; 
    }
}

export interface IINewOrganizationParams {
    name: string;
    orgType?: OrganizationType | null;
}

export class HarvestVm implements IHarvestVm {
    farm: FarmVm = new FarmVm();
    entries: EntryVm[] = [];
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;

    constructor(data?: IHarvestVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.farm = data["farm"] ? FarmVm.fromJS(data["farm"]) : new FarmVm();
            if (data["entries"] && data["entries"].constructor === Array) {
                this.entries = [];
                for (let item of data["entries"])
                    this.entries.push(EntryVm.fromJS(item));
            }
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.updatedOn = data["updatedOn"] ? moment(data["updatedOn"].toString()) : <any>null;
            this._id = data["_id"] !== undefined ? data["_id"] : <any>null;
        }
    }

    static fromJS(data: any): HarvestVm {
        let result = new HarvestVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["farm"] = this.farm ? this.farm.toJSON() : <any>null;
        if (this.entries && this.entries.constructor === Array) {
            data["entries"] = [];
            for (let item of this.entries)
                data["entries"].push(item.toJSON());
        }
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["updatedOn"] = this.updatedOn ? this.updatedOn.toISOString() : <any>null;
        data["_id"] = this._id !== undefined ? this._id : <any>null;
        return data; 
    }
}

export interface IHarvestVm {
    farm: FarmVm;
    entries: EntryVm[];
    createdOn?: moment.Moment | null;
    updatedOn?: moment.Moment | null;
    _id?: string | null;
}

export class IHarvestParams implements IIHarvestParams {
    farmId: string;
    entriesIds?: string[] | null;
    harvestId?: string | null;

    constructor(data?: IIHarvestParams) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.farmId = data["farmId"] !== undefined ? data["farmId"] : <any>null;
            if (data["entriesIds"] && data["entriesIds"].constructor === Array) {
                this.entriesIds = [];
                for (let item of data["entriesIds"])
                    this.entriesIds.push(item);
            }
            this.harvestId = data["harvestId"] !== undefined ? data["harvestId"] : <any>null;
        }
    }

    static fromJS(data: any): IHarvestParams {
        let result = new IHarvestParams();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["farmId"] = this.farmId !== undefined ? this.farmId : <any>null;
        if (this.entriesIds && this.entriesIds.constructor === Array) {
            data["entriesIds"] = [];
            for (let item of this.entriesIds)
                data["entriesIds"].push(item);
        }
        data["harvestId"] = this.harvestId !== undefined ? this.harvestId : <any>null;
        return data; 
    }
}

export interface IIHarvestParams {
    farmId: string;
    entriesIds?: string[] | null;
    harvestId?: string | null;
}

export class PercentageReportResponse implements IPercentageReportResponse {
    type?: string | null;
    createdOn?: moment.Moment | null;
    percentage?: string | null;

    constructor(data?: IPercentageReportResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(data?: any) {
        if (data) {
            this.type = data["type"] !== undefined ? data["type"] : <any>null;
            this.createdOn = data["createdOn"] ? moment(data["createdOn"].toString()) : <any>null;
            this.percentage = data["percentage"] !== undefined ? data["percentage"] : <any>null;
        }
    }

    static fromJS(data: any): PercentageReportResponse {
        let result = new PercentageReportResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type !== undefined ? this.type : <any>null;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>null;
        data["percentage"] = this.percentage !== undefined ? this.percentage : <any>null;
        return data; 
    }
}

export interface IPercentageReportResponse {
    type?: string | null;
    createdOn?: moment.Moment | null;
    percentage?: string | null;
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if(result !== null && result !== undefined)
        return Observable.throw(result);
    else
        return Observable.throw(new SwaggerException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader(); 
            reader.onload = function() { 
                observer.next(this.result);
                observer.complete();
            }
            reader.readAsText(blob); 
        }
    });
}